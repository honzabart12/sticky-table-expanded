/**
 * Vanilla Javascript Sticky Table v1.0.0
 * https://zhitkovkostya.github.io/sticky-table
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.StickyTable = factory());
})(this, (function () { 'use strict';

    class StickyTable {
      /**
       * Initial render of the table.
       *
       * @param tableElement - Table DOM element.
       */
      constructor(tableElement) {
        this.el = tableElement;
        this.wrapperElement = null;
        this.headWrapperElement = null;
        this.bodyWrapperElement = null;
        this.headTableElement = null;
        this.bodyTableElement = null;
        this.scrollLeft = 0;
        this._handleWindowScrollThrottled = this._throttle(this._handleWindowScroll.bind(this), 20);
        this._handleWindowResizeThrottled = this._throttle(this._handleWindowResize.bind(this), 20);
        this._handleHeadWrapperHorizontalScrollThrottled = this._throttle(this._handleHorizontalScroll.bind(this), 10);
        this._handleBodyWrapperHorizontalScrollThrottled = this._throttle(this._handleHorizontalScroll.bind(this), 10);

        this._wrapTable();

        this._wrapTableHead();

        this._wrapTableBody();

        this._syncColumnWidth();

        this._syncHeadPosition();

        window.addEventListener('scroll', this._handleWindowScrollThrottled, false);
        window.addEventListener('resize', this._handleWindowResizeThrottled);
      }
      /**
       * Wraps table in a new container.
       */


      _wrapTable() {
        const tableWrapperElement = document.createElement('div');
        tableWrapperElement.className = 'js-table-wrapper';

        if (this.el && this.el.parentNode) {
          this.el.parentNode.insertBefore(tableWrapperElement, this.el);
          tableWrapperElement.append(this.el);
        }

        this.wrapperElement = tableWrapperElement;
      }
      /**
       * Wraps table head in a new table with a scrollable container.
       */


      _wrapTableHead() {
        var _a;

        const tableHeadOriginalElement = this.el ? this.el.tHead : null;

        if (!tableHeadOriginalElement) {
          throw new Error('<thead> is missing');
        }

        const tableHeadCloneElement = tableHeadOriginalElement.cloneNode(true);

        this._toggleHeadVisibility(false);

        this.headWrapperElement = document.createElement('div');
        this.headTableElement = document.createElement('table');
        this.headWrapperElement.className = 'js-table-head-wrapper';
        this.headWrapperElement.dataset.isFixed = 'false';
        this.headWrapperElement.style.overflowX = 'auto';
        this.headWrapperElement.ariaHidden = 'true';
        this.headWrapperElement.appendChild(this.headTableElement).appendChild(tableHeadCloneElement);
        (_a = this.wrapperElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.headWrapperElement, this.el);
        this.headWrapperElement.addEventListener('scroll', this._handleHeadWrapperHorizontalScrollThrottled, false);
      }
      /**
       * Wraps table body in a new table with a scrollable container.
       */


      _wrapTableBody() {
        var _a;

        this.bodyWrapperElement = document.createElement('div');
        this.bodyWrapperElement.className = 'js-table-body-wrapper';
        this.bodyWrapperElement.style.overflowX = 'auto';

        if (this.el) {
          (_a = this.wrapperElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.bodyWrapperElement, this.el);
          this.bodyWrapperElement.appendChild(this.el);
        }

        this.bodyWrapperElement.addEventListener('scroll', this._handleBodyWrapperHorizontalScrollThrottled, false);
      }
      /**
       * Aligns hidden and visible table header widths.
       */


      _syncColumnWidth() {
        const headTableElement = this.headTableElement;
        const bodyTableElement = this.el;
        let headTableCellElement;
        let bodyTableCellWidth;
        let bodyTableCellStyle;

        if (!headTableElement || !bodyTableElement || !bodyTableElement.tHead || !headTableElement.tHead) {
          return;
        }

        for (const bodyTableRowElement of bodyTableElement.tHead.rows) {
          for (const bodyTableCellElement of bodyTableRowElement.cells) {
            headTableCellElement = headTableElement.tHead.rows[bodyTableRowElement.rowIndex].cells[bodyTableCellElement.cellIndex];
            bodyTableCellStyle = window.getComputedStyle(bodyTableCellElement);
            bodyTableCellWidth = Number(bodyTableCellElement.getBoundingClientRect().width.toFixed(2));

            if (bodyTableCellStyle.boxSizing === 'content-box') {
              bodyTableCellWidth -= parseFloat(bodyTableCellStyle.paddingLeft);
              bodyTableCellWidth -= parseFloat(bodyTableCellStyle.paddingRight);
            }

            headTableCellElement.style.minWidth = `${bodyTableCellWidth}px`;
            headTableCellElement.style.maxWidth = `${bodyTableCellWidth}px`;
          }
        }
      }
      /**
       * Fixes table head to the top of the viewport.
       */


      _syncHeadPosition() {
        if (!this.headWrapperElement || !this.bodyWrapperElement) {
          return;
        }

        let isHeadFixed = this.headWrapperElement.dataset.isFixed === 'true';
        const {
          width: headWrapperWidth,
          height: headWrapperHeight
        } = this.headWrapperElement.getBoundingClientRect();
        const {
          top: bodyWrapperOffestTop,
          width: bodyWrapperWidth,
          height: bodyWrapperHeight
        } = this.bodyWrapperElement.getBoundingClientRect();
        const bodyWrapperOffestLimit = isHeadFixed ? 0 : headWrapperHeight;
        const bodyWrapperBottomLimit = headWrapperHeight * 2;
        const isHeadTopInViewport = bodyWrapperOffestTop >= bodyWrapperOffestLimit;
        const isBodyBottomOutsideViewport = bodyWrapperHeight + bodyWrapperOffestTop - headWrapperHeight <= 0;

        if (isHeadFixed && (isHeadTopInViewport || isBodyBottomOutsideViewport)) {
          this.headWrapperElement.style.position = '';
          this.headWrapperElement.style.top = '';
          this.headWrapperElement.style.zIndex = '';
          this.headWrapperElement.style.width = '';
          this.bodyWrapperElement.style.paddingTop = '';
          this.headWrapperElement.dataset.isFixed = 'false';
          isHeadFixed = false;
        } else if (!isHeadFixed && !isHeadTopInViewport && !isBodyBottomOutsideViewport) {
          this.headWrapperElement.style.position = 'fixed';
          this.headWrapperElement.style.top = '0';
          this.headWrapperElement.style.zIndex = '2';
          this.headWrapperElement.style.width = bodyWrapperWidth + 'px';
          this.bodyWrapperElement.style.paddingTop = headWrapperHeight + 'px';
          this.headWrapperElement.dataset.isFixed = 'true';
          isHeadFixed = true;
        }

        if (isHeadFixed && bodyWrapperHeight + bodyWrapperOffestTop < bodyWrapperBottomLimit) {
          this.headWrapperElement.style.transform = 'translate3d(0, ' + (bodyWrapperHeight + bodyWrapperOffestTop - bodyWrapperBottomLimit) + 'px, 0)';
        } else {
          this.headWrapperElement.style.transform = '';
        } // Sync table head width with its body on window resize


        if (headWrapperWidth !== bodyWrapperWidth) {
          this.headWrapperElement.style.width = bodyWrapperWidth + 'px';
        }
      }
      /**
       * Aligns horizontal scroll values between table head and body containers.
       *
       * @returns
       */


      _syncHorizontalScroll(scrolledElement, targetElement) {
        const scrollLeft = scrolledElement.scrollLeft; // const tableRowHeadingElements = this.wrapperElement.querySelectorAll('.table__cell--locked');

        if (this.scrollLeft === scrollLeft) {
          return;
        }

        this.scrollLeft = scrollLeft;
        targetElement.scrollLeft = scrollLeft; // tableRowHeadingElements.forEach(tableRowHeadingElement => {
        //     tableRowHeadingElement.style.left = `${scrollLeft}px`;
        // });
      }
      /**
       * Accessibly hides or shows table head an innder cells.
       *
       * @param isShow - toggle state.
       */


      _toggleHeadVisibility(isShow = false) {
        const tableHeadOriginalElement = this.el ? this.el.tHead : null;

        if (!tableHeadOriginalElement) {
          throw new Error('<thead> is missing');
        }

        const tableHeadOriginalRows = Array.from(tableHeadOriginalElement.rows);
        const tableHeadOriginalCellsByRow = tableHeadOriginalRows.map(row => Array.from(row.cells));
        const tableHeadOriginalCells = [].concat(...tableHeadOriginalCellsByRow); // Visibility collapse hides the table head visually, but makes it visible for screen readers.

        tableHeadOriginalElement.style.visibility = isShow ? '' : 'collapse'; // Safari treats `visibility: collapse` like hidden leaving a white gap, so we hide inner cells manually.

        tableHeadOriginalCells.forEach(tableCellElement => {
          tableCellElement.style.height = isShow ? '' : '0';
          tableCellElement.style.paddingTop = isShow ? '' : '0';
          tableCellElement.style.paddingBottom = isShow ? '' : '0';
          tableCellElement.style.lineHeight = isShow ? '' : '0';
        });
      }
      /**
       * Handles horizontal scrolling.
       *
       * @param event - scroll event.
       */


      _handleHorizontalScroll(event) {
        const scrolledElement = event.target;
        const targetElement = scrolledElement.nextSibling || scrolledElement.previousSibling;

        this._syncHorizontalScroll(scrolledElement, targetElement);
      }
      /**
       * Handles window scrolling.
       */


      _handleWindowScroll() {
        this._syncHeadPosition();
      }
      /**
       * Handles window resize.
       */


      _handleWindowResize() {
        this._syncColumnWidth();
      }
      /**
       * Executes the given function once in an interval.
       *
       * @param fn - callback function
       * @param wait - time to wait for next call
       * @returns
       */


      _throttle(func, wait = 100) {
        let timer = null;
        return (...args) => {
          if (timer === null) {
            timer = setTimeout(() => {
              func.apply(this, args);
              timer = null;
            }, wait);
          }
        };
      }
      /**
       * Destroys the sticky table.
       *
       * @public
       */


      destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;

        window.removeEventListener('scroll', this._handleWindowScrollThrottled, false);
        window.removeEventListener('resize', this._handleWindowResizeThrottled);
        (_a = this.headWrapperElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', this._handleHeadWrapperHorizontalScrollThrottled, false);
        (_b = this.bodyWrapperElement) === null || _b === void 0 ? void 0 : _b.removeEventListener('scroll', this._handleBodyWrapperHorizontalScrollThrottled, false);

        while ((_c = this.bodyWrapperElement) === null || _c === void 0 ? void 0 : _c.firstChild) {
          (_d = this.wrapperElement) === null || _d === void 0 ? void 0 : _d.insertBefore((_e = this.bodyWrapperElement) === null || _e === void 0 ? void 0 : _e.firstChild, this.bodyWrapperElement);
        }

        while ((_f = this.wrapperElement) === null || _f === void 0 ? void 0 : _f.firstChild) {
          (_g = this.wrapperElement.parentElement) === null || _g === void 0 ? void 0 : _g.insertBefore((_h = this.wrapperElement) === null || _h === void 0 ? void 0 : _h.firstChild, this.wrapperElement);
        }

        this._toggleHeadVisibility(true);

        (_j = this.headWrapperElement) === null || _j === void 0 ? void 0 : _j.remove();
        (_k = this.bodyWrapperElement) === null || _k === void 0 ? void 0 : _k.remove();
        (_l = this.wrapperElement) === null || _l === void 0 ? void 0 : _l.remove();
        this.el = null;
        this.headWrapperElement = null;
        this.headTableElement = null;
        this.bodyWrapperElement = null;
        this.wrapperElement = null;
      }

    }

    return StickyTable;

}));
